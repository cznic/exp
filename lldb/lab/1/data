// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lldb

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/cznic/sortutil"
)

//TODO +BTreeEnumerator versioning?

const (
	kData             = 256         // [1, 512]
	kIndex            = 256         // [2, 2048]
	kKV               = 19          // Size of the key/value field in btreeDataPage
	kSz               = kKV - 1 - 7 // Content prefix size
	kH                = kKV - 7     // Content field offset for handle
	tagBTreeDataPage  = 1
	tagBTreeIndexPage = 0
)

// BTree is a B+tree[1][2], i.e. a variant which speeds up
// enumeration/iteration of the BTree. According to its origin it can be
// volatile (backed only by memory) or non-volatile (backed by a non-volatile
// Allocator).
//
// The specific implementation of BTrees in this package are B+trees with
// delayed split/concatenation (discussed in e.g. [3]).
//
// Note: No BTree methods returns io.EOF for physical Filer reads/writes.  The
// io.EOF is returned only by BTreeEnumerator methods to indicate "no more K-V
// pair".
//
//  [1]: http://en.wikipedia.org/wiki/B+tree
//  [2]: http://zgking.com:8080/home/donghui/publications/books/dshandbook_BTree.pdf
//  [3]: http://people.cs.aau.dk/~simas/aalg06/UbiquitBtree.pdf
type BTree struct {
	store   btreeStore
	root    btree
	collate func(a, b []byte) int
}

// NewBTree returns a new, memory-only BTree.
func NewBTree(collate func(a, b []byte) int) *BTree {
	store := newMemBTreeStore()
	root, err := newBTree(store)
	if err != nil { // should not happen
		panic(err.Error())
	}

	return &BTree{store, root, collate}
}

// IsMem reports if t is a memory only BTree.
func (t *BTree) IsMem() (r bool) {
	_, r = t.store.(*memBTreeStore)
	return
}

// Clear empties the tree.
func (t *BTree) Clear() (err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	return t.root.clear(t.store)
}

// Delete deletes key and its associated value from the tree.
func (t *BTree) Delete(key []byte) (err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	_, err = t.root.extract(t.store, nil, t.collate, key)
	return
}

// DeleteAny deletes one key and its associated value from the tree. If the
// tree is empty on return then empty is true.
func (t *BTree) DeleteAny() (empty bool, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	return t.root.deleteAny(t.store)
}

func elem(v interface{}) string {
	switch x := v.(type) {
	default:
		panic("internal error")
	case nil:
		return "nil"
	case bool:
		if x {
			return "true"
		}

		return "false"
	case int64:
		return fmt.Sprint(x)
	case uint64:
		return fmt.Sprint(x)
	case float64:
		s := fmt.Sprintf("%g", x)
		if !strings.Contains(s, ".") {
			s += "."
		}
		return s
	case complex128:
		s := fmt.Sprint(x)
		return s[1 : len(s)-1]
	case []byte:
		return fmt.Sprintf("[]byte{% 02x}", x)
	case string:
		return fmt.Sprintf("%q", x)
	}
}

// Dump outputs a human readable dump of t to w. It is usable iff t keys and
// values are encoded scalars (see EncodeScalars). Intended use is only for
// examples or debugging. Some type information is lost in the rendering, for
// example a float value '17.' and an integer value '17' may both output as
// '17'.
func (t *BTree) Dump(w io.Writer) (err error) {
	enum, err := t.SeekFirst()
	if err != nil {
		return
	}

	for {
		bkey, bval, err := enum.Current()
		if err != nil {
			return err
		}

		key, err := DecodeScalars(bkey)
		if err != nil {
			return err
		}

		val, err := DecodeScalars(bval)
		if err != nil {
			return err
		}

		kk := []string{}
		if key == nil {
			kk = []string{"null"}
		}
		for _, v := range key {
			kk = append(kk, elem(v))
		}
		vv := []string{}
		if val == nil {
			vv = []string{"null"}
		}
		for _, v := range val {
			vv = append(vv, elem(v))
		}
		skey := strings.Join(kk, ", ")
		sval := strings.Join(vv, ", ")
		if len(vv) > 1 {
			sval = fmt.Sprintf("[]interface{%s}", sval)
		}
		if _, err = fmt.Fprintf(w, "%s â†’ %s\n", skey, sval); err != nil {
			return err
		}

		err = enum.Next()
		if err != nil {
			if err == io.EOF {
				err = nil
				break
			}

			return err
		}
	}
	return
}

// Extract is a combination of Get and Delete. If the key exists in the tree,
// it is returned (like Get) and also deleted from a tree in a more efficient
// way which doesn't walk it twice.
func (t *BTree) Extract(key []byte) (value []byte, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	return t.root.extract(t.store, nil, t.collate, key)
}

// First returns the first KV pair of the tree, if it exists. Otherwise key == nil
// and value == nil.
func (t *BTree) First() (key, value []byte, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	var p btreeDataPage
	if _, p, err = t.root.first(t.store); err != nil || p == nil {
		return
	}

	if key, err = p.key(t.store, 0); err != nil {
		return
	}

	value, err = p.value(t.store, 0)
	return
}

// Get returns the value associated with key, or nil if no such value exists.
func (t *BTree) Get(key []byte) (value []byte, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	return t.root.get(t.store, nil, t.collate, key)
}

// Handle reports t's handle.
func (t *BTree) Handle() int64 {
	return int64(t.root)
}

// Last returns the last KV pair of the tree, if it exists. Otherwise key == nil
// and value == nil.
func (t *BTree) Last() (key, value []byte, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	var p btreeDataPage
	if _, p, err = t.root.last(t.store); err != nil || p == nil {
		return
	}

	index := p.len() - 1
	if key, err = p.key(t.store, index); err != nil {
		return
	}

	value, err = p.value(t.store, index)
	return
}

// Put combines Get and Set in a more efficient way where the tree is walked
// only once.  The upd(ater) receives the current (key, old-value), if that
// exists or (key, nil) otherwise.  It can than return a (new-value, true, nil)
// to create or overwrite the existing value in the KV pair, or (whatever,
// false, nil) if it decides not to create or not to update the value of the KV
// pair.
//
// 	tree.Set(k, v)
//
// conceptually equals
//
// 	tree.Put(k, func(k, v []byte){ return v, true }([]byte, bool))
//
// modulo the differing return values.
func (t *BTree) Put(key []byte, upd func(key, old []byte) (new []byte, write bool, err error)) (old []byte, written bool, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	return t.root.put2(t.store, t.collate, key, upd)
}

// Seek returns an enumerator with "position" or an error of any. Normally the
// position is on a KV pair such that key >= KV.key. Then hit is key == KV.key.
// The position is possibly "after" the last KV pair, but that is not an error.
func (t *BTree) Seek(key []byte) (enum *BTreeEnumerator, hit bool, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	r := &BTreeEnumerator{a: t.store, collate: t.collate}
	if r.p, r.index, hit, err = t.root.seek(r.a, r.collate, key); err != nil {
		return
	}

	enum = r
	return
}

// SeekFirst returns an enumerator positioned on the first KV pair in the tree,
// if any.  For an empty tree, err == io.EOF is returend.
func (t *BTree) SeekFirst() (enum *BTreeEnumerator, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	var p btreeDataPage
	if _, p, err = t.root.first(t.store); err == nil && p == nil {
		err = io.EOF
	}
	if err != nil {
		return
	}

	return &BTreeEnumerator{a: t.store, collate: t.collate, p: p, index: 0}, nil
}

// SeekLast returns an enumerator positioned on the last KV pair in the tree,
// if any.  For an empty tree, err == io.EOF is returend.
func (t *BTree) SeekLast() (enum *BTreeEnumerator, err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	var p btreeDataPage
	if _, p, err = t.root.last(t.store); err == nil && p == nil {
		err = io.EOF
	}
	if err != nil {
		return
	}

	return &BTreeEnumerator{a: t.store, collate: t.collate, p: p, index: p.len() - 1}, nil
}

// Set sets the value associated with key. Any previous value, if existed, is
// overwritten by the new one.
func (t *BTree) Set(key, value []byte) (err error) {
	if t == nil {
		err = errors.New("BTree method invoked on nil receiver")
		return
	}

	_, err = t.root.put(t.store, t.collate, key, value, true)
	return
}

// BTreeEnumerator is a closure of a BTree and a position. It is returned from
// BTree.Seek.
//
// NOTE: BTreeEnumerator cannot be used after its BTree was mutated after the
// BTreeEnumerator was acquired from any of the Seek, SeekFirst, SeekLast
// methods.
type BTreeEnumerator struct {
	a       btreeStore
	collate func(a, b []byte) int
	p       btreeDataPage
	index   int
}

// Current returns the KV pair the enumerator is currently positioned on. If
// the position is before the first KV pair in the tree or after the last KV
// pair in the tree then err == io.EOF is returned.
func (e *BTreeEnumerator) Current() (key, value []byte, err error) {
	if e == nil {
		err = errors.New("BTreeEnumerator method invoked on nil receiver")
		return
	}

	if e.p == nil || e.index == e.p.len() {
		return nil, nil, io.EOF
	}

	if key, err = e.p.key(e.a, e.index); err != nil {
		return
	}

	value, err = e.p.value(e.a, e.index)
	return
}

// Next attempts to position the enumerator onto the next KV pair wrt the
// current position. If there is no "next" KV pair, io.EOF is returned.
func (e *BTreeEnumerator) Next() (err error) {
	if e == nil {
		err = errors.New("BTreeEnumerator method invoked on nil receiver")
		return
	}

	if e.p == nil {
		return io.EOF
	}

	switch {
	case e.index < e.p.len()-1:
		e.index++
	default:
		ph := e.p.next()
		if ph == 0 {
			err = io.EOF
			break
		}

		if e.p, err = e.a.Get(e.p, ph); err != nil {
			e.p = nil
			return
		}
		e.index = 0
	}
	return
}

// Prev attempts to position the enumerator onto the previous KV pair wrt the
// current position. If there is no "previous" KV pair, io.EOF is returned.
func (e *BTreeEnumerator) Prev() (err error) {
	if e == nil {
		err = errors.New("BTreeEnumerator method invoked on nil receiver")
		return
	}

	if e.p == nil {
		return io.EOF
	}

	switch {
	case e.index > 0:
		e.index--
	default:
		ph := e.p.prev()
		if ph == 0 {
			err = io.EOF
			break
		}

		if e.p, err = e.a.Get(e.p, ph); err != nil {
			e.p = nil
			return
		}
		e.index = e.p.len() - 1
	}
	return
}

// CreateBTree creates a new BTree in store. It returns the tree, its (freshly
// assigned) handle (for OpenBTree or RemoveBTree) or an error, if any.
func CreateBTree(store *Allocator, collate func(a, b []byte) int) (bt *BTree, handle int64, err error) {
	r := &BTree{store: store, collate: collate}
	if r.root, err = newBTree(store); err != nil {
		return
	}

	return r, int64(r.root), nil
}

// OpenBTree opens a store's BTree using handle. It returns the tree or an
// error, if any. The same tree may be opened more than once, but operations on
// the separate instances should not ever overlap or void the other instances.
// However, the intended API usage is to open the same tree handle only once
// (handled by some upper layer "dispatcher").
func OpenBTree(store *Allocator, collate func(a, b []byte) int, handle int64) (bt *BTree, err error) {
	r := &BTree{store: store, root: btree(handle), collate: collate}
	var b []byte
	if b, err = store.Get(nil, handle); err != nil {
		return
	}

	if len(b) != 7 {
		return nil, &ErrILSEQ{Off: h2off(handle)}
	}

	return r, nil
}

// RemoveBTree removes tree, represented by handle from store. Empty trees are
// cheap, each uses only few bytes of the store. If there's a chance that a
// tree will eventually get reused (non empty again), it's recommended to
// not/never remove it.  One advantage of such approach is a stable handle of
// such tree.
func RemoveBTree(store *Allocator, handle int64) (err error) {
	tree, err := OpenBTree(store, nil, handle)
	if err != nil {
		return
	}

	if err = tree.Clear(); err != nil {
		return
	}

	return store.Free(handle)
}

type btreeStore interface {
	Alloc(b []byte) (handle int64, err error)
	Free(handle int64) (err error)
	Get(dst []byte, handle int64) (b []byte, err error)
	Realloc(handle int64, b []byte) (err error)
}

// Read only zero bytes
var zeros [2 * kKV]byte

func init() {
	if kData < 1 || kData > 512 {
		panic(fmt.Errorf("kData %d: out of limits", kData))
	}

	if kIndex < 2 || kIndex > 2048 {
		panic(fmt.Errorf("kIndex %d: out of limits", kIndex))
	}

	if kKV < 8 || kKV > 23 {
		panic(fmt.Errorf("kKV %d: out of limits", kKV))
	}
}

type memBTreeStore struct {
	h int64
	m map[int64][]byte
}

func newMemBTreeStore() *memBTreeStore {
	return &memBTreeStore{0, map[int64][]byte{}}
}

func (s *memBTreeStore) String() string {
	var a sortutil.Int64Slice
	for k := range s.m {
		a = append(a, k)
	}
	sort.Sort(a)
	var sa []string
	for _, k := range a {
		sa = append(sa, fmt.Sprintf("%#x:|% x|", k, s.m[k]))
	}
	return strings.Join(sa, "\n")
}

func (s *memBTreeStore) Alloc(b []byte) (handle int64, err error) {
	s.h++
	handle = s.h
	s.m[handle] = bpack(b)
	return
}

func (s *memBTreeStore) Free(handle int64) (err error) {
	if _, ok := s.m[handle]; !ok {
		return &ErrILSEQ{Type: ErrOther, Off: h2off(handle)}
	}

	delete(s.m, handle)
	return
}

func (s *memBTreeStore) Get(dst []byte, handle int64) (b []byte, err error) {
	r, ok := s.m[handle]
	if !ok {
		return nil, &ErrILSEQ{Type: ErrOther, Off: h2off(handle)}
	}

	b = need(len(r), dst)
	copy(b, r)
	return
}

func (s *memBTreeStore) Realloc(handle int64, b []byte) (err error) {
	if _, ok := s.m[handle]; !ok {
		return &ErrILSEQ{Type: ErrOther, Off: h2off(handle)}
	}

	s.m[handle] = bpack(b)
	return
}

/*

0...0 (1 bytes):
Flag

	  0
	+---+
	| 0 |
	+---+

0 indicates an index page

1...count*14-1
"array" of items, 14 bytes each. Count of items in kIndex-1..2*kIndex+2

	Count = (len(raw) - 8) / 14

	  0..6     7..13
	+-------+----------+
	| Child | DataPage |
	+-------+----------+

	Child    == handle of a child index page
	DataPage == handle of a data page

Offsets into the raw []byte:
Child[X]    == 1+14*X
DataPage[X] == 8+14*X

*/
type btreeIndexPage []byte

func newBTreeIndexPage(leftmostChild int64) (p btreeIndexPage) {
	p = make([]byte, 8, 1+(kIndex+1)*2*7)
	p[0] = tagBTreeIndexPage
	h2b(p[1:], leftmostChild)
	return
}

func (p btreeIndexPage) len() int {
	return (len(p) - 8) / 14
}

func (p btreeIndexPage) child(index int) int64 {
	return b2h(p[1+14*index:])
}

func (p btreeIndexPage) setChild(index int, dp int64) {
	h2b(p[1+14*index:], dp)
}

func (p btreeIndexPage) dataPage(index int) int64 {
	return b2h(p[8+14*index:])
}

func (p btreeIndexPage) setDataPage(index int, dp int64) {
	h2b(p[8+14*index:], dp)
}

func (p *btreeIndexPage) insert(index int) {
	q := *p
	switch len0 := p.len(); {
	case index < len0:
		has := len(q)
		need := has + 14
		switch {
		case cap(q) >= need:
			q = q[:need]
		default:
			q = append(q, zeros[:14]...)
		}
		copy(q[8+14*(index+1):8+14*(index+1)+2*(len0-index)*7], q[8+14*index:])
	case index == len0:
		has := len(q)
		need := has + 14
		switch {
		case cap(q) >= need:
			q = q[:need]
		default:
			q = append(q, zeros[:14]...)
		}
	}
	*p = q
	return
}

func (p *btreeIndexPage) insert3(index int, dataPage, child int64) {
	p.insert(index)
	p.setDataPage(index, dataPage)
	p.setChild(index+1, child)
	return
}

func (p btreeIndexPage) cmp(a btreeStore, c func(a, b []byte) int, keyA []byte, keyBIndex int) (int, error) {
	dp, err := a.Get(nil, p.dataPage(keyBIndex))
	if err != nil {
		return 0, err
	}

	return btreeDataPage(dp).cmp(a, c, keyA, 0)
}

func (p *btreeIndexPage) setLen(n int) {
	q := *p
	q = q[:cap(q)]
	need := 8 + 14*n
	if need < len(q) {
		*p = q[:need]
		return
	}
	*p = append(q, make([]byte, need-len(q))...)
	return
}

func (p *btreeIndexPage) split(a btreeStore, root btree, ph *int64, parent int64, parentIndex int, index *int) error {
	right := newBTreeIndexPage(0)
	right.setLen(kIndex)
	copy(right[1:1+(2*kIndex+1)*7], (*p)[1+14*(kIndex+1):])
	p.setLen(kIndex)
	if err := a.Realloc(*ph, *p); err != nil {
		return err
	}

	rh, err := a.Alloc(right)
	if err != nil {
		return err
	}

	if parentIndex >= 0 {
		var pp btreeIndexPage
		pp, err = a.Get(nil, parent)
		if err != nil {
			return err
		}
		pp.insert3(parentIndex, p.dataPage(kIndex), rh)
		if err = a.Realloc(parent, pp); err != nil {
			return err
		}

	} else {
		nr := newBTreeIndexPage(*ph)
		nr.insert3(0, p.dataPage(kIndex), rh)
		nrh, err := a.Alloc(nr)
		if err != nil {
			return err
		}

		if err = a.Realloc(int64(root), h2b(make([]byte, 7), nrh)); err != nil {
			return err
		}
	}
	if *index > kIndex {
		*p = right
		*ph = rh
		*index -= kIndex + 1
	}
	return nil
}

// p is dirty on return
func (p *btreeIndexPage) extract(index int) {
	n := p.len() - 1
	if index < n {
		sz := (n-index)*14 + 7
		copy((*p)[1+14*index:1+14*index+sz], (*p)[1+14*(index+1):])
	}
	p.setLen(n)
	return
}

// must persist all changes made
func (p *btreeIndexPage) underflow(a btreeStore, root, iroot, parent int64, ph *int64, parentIndex int, index *int) (err error) {
	lh, rh, err := checkSiblings(a, parent, parentIndex)
	if err != nil {
		return err
	}

	var left btreeIndexPage

	if lh != 0 {
		if left, err = a.Get(nil, lh); err != nil {
			return err
		}

		if lc := btreeIndexPage(left).len(); lc > kIndex {
			pp, err := a.Get(nil, parent)
			if err != nil {
				return err
			}

			pc := p.len()
			p.setLen(pc + 1)
			di, si, sz := 1+1*14, 1+0*14, (2*pc+1)*7
			copy((*p)[di:di+sz], (*p)[si:])
			p.setChild(0, btreeIndexPage(left).child(lc))
			p.setDataPage(0, btreeIndexPage(pp).dataPage(parentIndex-1))
			*index++
			btreeIndexPage(pp).setDataPage(parentIndex-1, btreeIndexPage(left).dataPage(lc-1))
			(*btreeIndexPage)(&left).setLen(lc - 1)
			if err = a.Realloc(parent, pp); err != nil {
				return err
			}

			if err = a.Realloc(*ph, *p); err != nil {
				return err
			}

			return a.Realloc(lh, left)
		}
	}

	if rh != 0 {
		right, err := a.Get(nil, rh)
		if err != nil {
			return err
		}

		if rc := btreeIndexPage(right).len(); rc > kIndex {
			pp, err := a.Get(nil, parent)
			if err != nil {
				return err
			}

			pc := p.len()
			p.setLen(pc + 1)
			p.setDataPage(pc, btreeIndexPage(pp).dataPage(parentIndex))
			pc++
			p.setChild(pc, btreeIndexPage(right).child(0))
			btreeIndexPage(pp).setDataPage(parentIndex, btreeIndexPage(right).dataPage(0))
			di, si, sz := 1+0*14, 1+1*14, (2*rc+1)*7
			copy(right[di:di+sz], right[si:])
			(*btreeIndexPage)(&right).setLen(rc - 1)
			if err = a.Realloc(parent, pp); err != nil {
				return err
			}

			if err = a.Realloc(*ph, *p); err != nil {
				return err
			}

			return a.Realloc(rh, right)
		}
	}

	if lh != 0 {
		*index += left.len() + 1
		if err = left.concat(a, root, iroot, parent, lh, *ph, parentIndex-1); err != nil {
			return err
		}

		*p, *ph = left, lh
		return
	}

	return p.concat(a, root, iroot, parent, *ph, rh, parentIndex)
}

// must persist all changes made
func (p *btreeIndexPage) concat(a btreeStore, root, iroot, parent, ph, rh int64, parentIndex int) (err error) {
	pp, err := a.Get(nil, parent)
	if err != nil {
		return err
	}

	right, err := a.Get(nil, rh)
	if err != nil {
		return err
	}

	pc := p.len()
	rc := btreeIndexPage(right).len()
	p.setLen(pc + rc + 1)
	p.setDataPage(pc, btreeIndexPage(pp).dataPage(parentIndex))
	di, si, sz := 1+14*(pc+1), 1+0*14, (2*rc+1)*7
	copy((*p)[di:di+sz], right[si:])
	if err = a.Realloc(ph, *p); err != nil {
		return err
	}

	if err = a.Free(rh); err != nil {
		return
	}

	if pc := btreeIndexPage(pp).len(); pc > 1 {
		if parentIndex < pc-1 {
			di, si, sz := 8+parentIndex*14, 8+(parentIndex+1)*14, 2*(pc-1-parentIndex)*7
			copy(pp[di:si+sz], pp[si:])
		}
		(*btreeIndexPage)(&pp).setLen(pc - 1)
		return a.Realloc(parent, pp)
	}

	if err = a.Free(iroot); err != nil {
		return err
	}

	var b7 [7]byte
	return a.Realloc(root, h2b(b7[:7], ph))
}

/*

0...0 (1 bytes):
Flag

	  0
	+---+
	| 1 |
	+---+

1 indicates a data page

1...14 (14 bytes)

	  1..7  8..14
	+------+------+
	| Prev | Next |
	+------+------+

	Prev, Next == Handles of the data pages doubly linked list

	Count = (len(raw) - 15) / (2*kKV)

15...count*2*kKV-1
"array" of items, 2*kKV bytes each. Count of items in kData-1..2*kData

Item
	  0..kKV-1   kKV..2*kKV-1
	+----------+--------------+
	|   Key    |    Value     |
	+----------+--------------+

Key/Value encoding

Length 0...kKV-1

	  0    1...N    N+1...kKV-1
	+---+---------+-------------+
	| N |  Data   |  Padding    |
	+---+---------+-------------+

	N       == content length
	Data    == Key or Value content
	Padding == MUST be zero bytes

Length >= kKV

	   0     1...kkV-8   kKV-7...kkV-1
	+------+-----------+--------------+
	| 0xFF |   Data    |      H       |
	+------+-----------+--------------+

	Data == Key or Value content, first kKV-7 bytes
	H    == Handle to THE REST of the content, w/o the first bytes in Data.

Offsets into the raw []byte:
Key[X]   == 15+2*kKV*X
Value[X] == 15+kKV+2*kKV*X
*/
type btreeDataPage []byte

func newBTreeDataPage() (p btreeDataPage) {
	p = make([]byte, 1+2*7, 1+2*7+kData*2*kKV)
	p[0] = tagBTreeDataPage
	return
}

func newBTreeDataPageAlloc(a btreeStore) (p btreeDataPage, h int64, err error) {
	p = newBTreeDataPage()
	h, err = a.Alloc(p)
	return
}

func (p btreeDataPage) len() int {
	return (len(p) - 15) / (2 * kKV)
}

func (p *btreeDataPage) setLen(n int) {
	q := *p
	q = q[:cap(q)]
	need := 15 + 2*kKV*n
	if need < len(q) {
		*p = q[:need]
		return
	}
	*p = append(q, make([]byte, need-len(q))...)
	return
}

func (p btreeDataPage) prev() int64 {
	return b2h(p[1:])
}

func (p btreeDataPage) next() int64 {
	return b2h(p[8:])
}

func (p btreeDataPage) setPrev(h int64) {
	h2b(p[1:], h)
}

func (p btreeDataPage) setNext(h int64) {
	h2b(p[8:], h)
}

func (p *btreeDataPage) insert(index int) {
	q := *p
	switch len0 := p.len(); {
	case index < len0:
		has := len(q)
		need := has + 2*kKV
		switch {
		case cap(q) >= need:
			q = q[:need]
		default:
			q = append(q, zeros[:2*kKV]...)
		}
		q.copy(q, index+1, index, len0-index)
		*p = q
	case index == len0:
		has := len(q)
		need := has + 2*kKV
		switch {
		case cap(q) >= need:
			*p = q[:need]
		default:
			*p = append(q, zeros[:2*kKV]...)
		}
	}
	return
}

func (p btreeDataPage) contentField(off int) (b []byte, h int64) {
	p = p[off:]
	switch n := int(p[0]); {
	case n >= kKV: // content has a handle
		b = append([]byte(nil), p[1:1+kSz]...)
		h = b2h(p[kH:])
	default: // content is embedded
		b, h = p[1:1+n], 0
	}
	return
}

func (p btreeDataPage) content(a btreeStore, off int) (b []byte, err error) {
	b, h := p.contentField(off)
	if h == 0 {
		return
	}

	// content has a handle
	b2, err := a.Get(nil, h)
	if err != nil {
		return nil, err
	}

	return append(b, b2...), nil
}

func (p btreeDataPage) setContent(a btreeStore, off int, b []byte) (err error) {
	p = p[off:]
	switch {
	case p[0] >= kKV: // existing content has a handle
		switch n := len(b); {
		case n < kKV:
			p[0] = byte(n)
			if err = a.Free(b2h(p[kH:])); err != nil {
				return
			}
			copy(p[1:], b)
		default:
			// reuse handle
			copy(p[1:1+kSz], b)
			return a.Realloc(b2h(p[kH:]), b[kSz:])
		}
	default: // existing content is embedded
		switch n := len(b); {
		case n < kKV:
			p[0] = byte(n)
			copy(p[1:], b)
		default:
			p[0] = 0xff
			copy(p[1:1+kSz], b)
			h, err := a.Alloc(b[kSz:])
			if err != nil {
				return err
			}

			h2b(p[kH:], h)
		}
	}
	return
}

func (p btreeDataPage) keyField(index int) (b []byte, h int64) {
	return p.contentField(15 + 2*kKV*index)
}

func (p btreeDataPage) key(a btreeStore, index int) (b []byte, err error) {
	return p.content(a, 15+2*kKV*index)
}

func (p btreeDataPage) valueField(index int) (b []byte, h int64) {
	return p.contentField(15 + kKV + 2*kKV*index)
}

func (p btreeDataPage) value(a btreeStore, index int) (b []byte, err error) {
	return p.content(a, 15+kKV+2*kKV*index)
}

func (p btreeDataPage) valueCopy(a btreeStore, index int) (b []byte, err error) {
	if b, err = p.content(a, 15+kKV+2*kKV*index); err != nil {
		return
	}

	return append([]byte(nil), b...), nil
}

func (p btreeDataPage) setKey(a btreeStore, index int, key []byte) (err error) {
	return p.setContent(a, 15+2*kKV*index, key)
}

func (p btreeDataPage) setValue(a btreeStore, index int, value []byte) (err error) {
	return p.setContent(a, 15+kKV+2*kKV*index, value)
}

func (p btreeDataPage) cmp(a btreeStore, c func(a, b []byte) int, keyA []byte, keyBIndex int) (y int, err error) {
	var keyB []byte
	if keyB, err = p.content(a, 15+2*kKV*keyBIndex); err != nil {
		return
	}

	return c(keyA, keyB), nil
}

func (p btreeDataPage) copy(src btreeDataPage, di, si, n int) {
	do, so := 15+2*kKV*di, 15+2*kKV*si
	copy(p[do:do+2*kKV*n], src[so:])
}

// {p,left} dirty on exit
func (p *btreeDataPage) moveLeft(left *btreeDataPage, n int) {
	nl, np := left.len(), p.len()
	left.setLen(nl + n)
	left.copy(*p, nl, 0, n)
	p.copy(*p, 0, n, np-n)
	p.setLen(np - n)
	return
}

func (p *btreeDataPage) moveRight(right *btreeDataPage, n int) {
	nr, np := right.len(), p.len()
	right.setLen(nr + n)
	right.copy(*right, n, 0, nr)
	right.copy(*p, 0, np-n, n)
	p.setLen(np - n)
	return
}

func (p *btreeDataPage) insertItem(a btreeStore, index int, key, value []byte) (err error) {
	p.insert(index)
	di, sz := 15+2*kKV*index, 2*kKV
	copy((*p)[di:di+sz], zeros[:sz])
	if err = p.setKey(a, index, key); err != nil {
		return
	}
	return p.setValue(a, index, value)
}

func (p *btreeDataPage) split(a btreeStore, root, ph, parent int64, parentIndex, index int, key, value []byte) (err error) {
	right, rh, err := newBTreeDataPageAlloc(a)
	if err != nil {
		return err
	}

	if next := p.next(); next != 0 {
		right.setNext(p.next())
		nxh := right.next()
		nx, err := a.Get(nil, nxh)
		if err != nil {
			return err
		}

		btreeDataPage(nx).setPrev(rh)
		if err = a.Realloc(nxh, nx); err != nil {
			return err
		}
	}

	p.setNext(rh)
	right.setPrev(ph)
	right.setLen(kData)
	right.copy(*p, 0, kData, kData)
	p.setLen(kData)

	if parentIndex >= 0 {
		var pp btreeIndexPage
		if pp, err = a.Get(nil, parent); err != nil {
			return
		}

		pp.insert3(parentIndex, rh, rh)
		if err = a.Realloc(parent, pp); err != nil {
			return
		}

	} else {
		nr := newBTreeIndexPage(ph)
		nr.insert3(0, rh, rh)
		nrh, err := a.Alloc(nr)
		if err != nil {
			return err
		}

		if err = a.Realloc(root, h2b(make([]byte, 7), nrh)); err != nil {
			return err
		}

	}
	if index > kData {
		if err = right.insertItem(a, index-kData, key, value); err != nil {
			return err
		}
	} else {
		if err = p.insertItem(a, index, key, value); err != nil {
			return err
		}
	}
	if err = a.Realloc(ph, *p); err != nil {
		return
	}

	return a.Realloc(rh, right)
}

func (p *btreeDataPage) overflow(a btreeStore, root, ph, parent int64, parentIndex, index int, key, value []byte) (err error) {
	var leftH, rightH int64
	if leftH, rightH, err = checkSiblings(a, parent, parentIndex); err != nil {
		return
	}

	if leftH != 0 {
		var left btreeDataPage
		if left, err = a.Get(nil, leftH); err != nil {
			return
		}

		if left.len() < 2*kData {

			p.moveLeft(&left, 1)
			if err = a.Realloc(leftH, left); err != nil {
				return
			}

			if err = p.insertItem(a, index-1, key, value); err != nil {
				return
			}

			return a.Realloc(ph, *p)
		}
	}

	if rightH != 0 {
		var right btreeDataPage
		if right, err = a.Get(nil, rightH); err != nil {
			return
		}

		if right.len() < 2*kData {
			if index < 2*kData {
				p.moveRight(&right, 1)
				if err = a.Realloc(rightH, right); err != nil {
					return
				}

				if err = p.insertItem(a, index, key, value); err != nil {
					return
				}

				return a.Realloc(ph, *p)
			} else {
				if err = right.insertItem(a, 0, key, value); err != nil {
					return
				}

				return a.Realloc(rightH, right)
			}
		}
	}
	return p.split(a, root, ph, parent, parentIndex, index, key, value)
}

func (p btreeDataPage) swap(a btreeStore, di int, value []byte, canOverwrite bool) (oldValue []byte, err error) {
	if oldValue, err = p.value(a, di); err != nil {
		return
	}

	if !canOverwrite {
		return
	}

	oldValue = append([]byte(nil), oldValue...)
	err = p.setValue(a, di, value)
	return
}

type btreePage []byte

func (p btreePage) isIndex() bool {
	return p[0] == tagBTreeIndexPage
}

func (p btreePage) len() int {
	if p.isIndex() {
		return btreeIndexPage(p).len()
	}

	return btreeDataPage(p).len()
}

func (p btreePage) find(a btreeStore, c func(a, b []byte) int, key []byte) (index int, ok bool, err error) {
	l := 0
	h := p.len() - 1
	isIndex := p.isIndex()
	if c == nil {
		c = bytes.Compare
	}
	for l <= h {
		index = (l + h) >> 1
		var cmp int
		if isIndex {
			if cmp, err = btreeIndexPage(p).cmp(a, c, key, index); err != nil {
				return
			}
		} else {
			if cmp, err = btreeDataPage(p).cmp(a, c, key, index); err != nil {
				return
			}
		}
		switch ok = cmp == 0; {
		case cmp > 0:
			l = index + 1
		case ok:
			return
		default:
			h = index - 1
		}
	}
	return l, false, nil
}

// p is dirty after extract!
func (p *btreeDataPage) extract(a btreeStore, index int) (value []byte, err error) {
	if value, err = p.valueCopy(a, index); err != nil {
		return
	}

	if _, h := p.keyField(index); h != 0 {
		if err = a.Free(h); err != nil {
			return
		}
	}

	if _, h := p.valueField(index); h != 0 {
		if err = a.Free(h); err != nil {
			return
		}
	}

	n := p.len() - 1
	if index < n {
		p.copy(*p, index, index+1, n-index)
	}
	p.setLen(n)
	return
}

func checkSiblings(a btreeStore, parent int64, parentIndex int) (left, right int64, err error) {
	if parentIndex >= 0 {
		var p btreeIndexPage
		if p, err = a.Get(nil, parent); err != nil {
			return
		}

		if parentIndex > 0 {
			left = p.child(parentIndex - 1)
		}
		if parentIndex < p.len() {
			right = p.child(parentIndex + 1)
		}
	}
	return
}

// underflow must persist all changes made.
func (p btreeDataPage) underflow(a btreeStore, root, iroot, parent, ph int64, parentIndex int) (err error) {
	lh, rh, err := checkSiblings(a, parent, parentIndex)
	if err != nil {
		return err
	}

	if lh != 0 {
		left, err := a.Get(nil, lh)
		if err != nil {
			return err
		}

		if btreeDataPage(left).len()+p.len() >= 2*kData {
			(*btreeDataPage)(&left).moveRight(&p, 1)
			if err = a.Realloc(lh, left); err != nil {
				return err
			}

			return a.Realloc(ph, p)
		}
	}

	if rh != 0 {
		right, err := a.Get(nil, rh)
		if err != nil {
			return err
		}

		if p.len()+btreeDataPage(right).len() > 2*kData {
			(*btreeDataPage)(&right).moveLeft(&p, 1)
			if err = a.Realloc(rh, right); err != nil {
				return err
			}

			return a.Realloc(ph, p)
		}
	}

	if lh != 0 {
		left, err := a.Get(nil, lh)
		if err != nil {
			return err
		}

		if err = a.Realloc(ph, p); err != nil {
			return err
		}

		return btreeDataPage(left).concat(a, root, iroot, parent, lh, ph, parentIndex-1)
	}

	return p.concat(a, root, iroot, parent, ph, rh, parentIndex)
}

// concat must persist all changes made.
func (p btreeDataPage) concat(a btreeStore, root, iroot, parent, ph, rh int64, parentIndex int) (err error) {
	right, err := a.Get(nil, rh)
	if err != nil {
		return err
	}

	(*btreeDataPage)(&right).moveLeft(&p, btreeDataPage(right).len())
	nxh := btreeDataPage(right).next()
	if nxh != 0 {
		nx, err := a.Get(nil, nxh)
		if err != nil {
			return err
		}

		btreeDataPage(nx).setPrev(ph)
		if err = a.Realloc(nxh, nx); err != nil {
			return err
		}
	}
	p.setNext(nxh)
	if err = a.Free(rh); err != nil {
		return err
	}

	pp, err := a.Get(nil, parent)
	if err != nil {
		return err
	}

	if btreeIndexPage(pp).len() > 1 {
		(*btreeIndexPage)(&pp).extract(parentIndex)
		btreeIndexPage(pp).setChild(parentIndex, ph)
		if err = a.Realloc(parent, pp); err != nil {
			return err
		}

		return a.Realloc(ph, p)
	}

	if err = a.Free(iroot); err != nil {
		return err
	}

	if err = a.Realloc(ph, p); err != nil {
		return err
	}

	var b7 [7]byte
	return a.Realloc(root, h2b(b7[:], ph))
}

// external "root" is stable and contains the real root.
type btree int64

func newBTree(a btreeStore) (btree, error) {
	r, err := a.Alloc(zeros[:7])
	return btree(r), err
}

func (root btree) String(a btreeStore) string {
	r, err := a.Get(nil, int64(root))
	if err != nil {
		panic(err)
	}

	iroot := b2h(r)
	m := map[int64]bool{int64(root): true}

	s := []string{fmt.Sprintf("tree %#x -> %#x\n====", root, iroot)}
	if iroot == 0 {
		return s[0]
	}

	var f func(int64, string)
	f = func(h int64, ind string) {
		if m[h] {
			return
		}

		m[h] = true
		var b btreePage
		var err error
		if b, err = a.Get(nil, h); err != nil {
			panic(err)
		}

		s = append(s, fmt.Sprintf("%s@%#x", ind, h))
		switch b.isIndex() {
		case true:
			da := []int64{}
			b := btreeIndexPage(b)
			for i := 0; i < b.len(); i++ {
				c, d := b.child(i), b.dataPage(i)
				s = append(s, fmt.Sprintf("%schild[%d] %#x dataPage[%d] %#x", ind, i, c, i, d))
				da = append(da, c)
				da = append(da, d)
			}
			i := b.len()
			c := b.child(i)
			s = append(s, fmt.Sprintf("%schild[%d] %#x", ind, i, c))
			for _, c := range da {
				f(c, ind+"  ")
			}
			f(c, ind+"  ")
		case false:
			b := btreeDataPage(b)
			s = append(s, fmt.Sprintf("%sprev %#x next %#x", ind, b.prev(), b.next()))
			for i := 0; i < b.len(); i++ {
				k, err := b.key(a, i)
				if err != nil {
					panic(err)
				}

				v, err := b.value(a, i)
				if err != nil {
					panic(err)
				}

				s = append(s, fmt.Sprintf("%sK[%d]|% x| V[%d]|% x|", ind, i, k, i, v))
			}
		}
	}

	f(int64(iroot), "")
	return strings.Join(s, "\n")
}

func (root btree) put(a btreeStore, c func(a, b []byte) int, key, value []byte, canOverwrite bool) (prev []byte, err error) {
	prev, _, err = root.put2(a, c, key, func(key, old []byte) (new []byte, write bool, err error) {
		new, write = value, true
		return
	})
	return
}

func (root btree) put2(a btreeStore, c func(a, b []byte) int, key []byte, upd func(key, old []byte) (new []byte, write bool, err error)) (old []byte, written bool, err error) {
	var r, value []byte
	if r, err = a.Get(nil, int64(root)); err != nil {
		return
	}

	iroot := b2h(r)
	var h int64
	if iroot == 0 {
		p := newBTreeDataPage()
		if value, written, err = upd(key, nil); err != nil || !written {
			return
		}

		if err = p.insertItem(a, 0, key, value); err != nil {
			return
		}

		h, err = a.Alloc(p)
		if err != nil {
			return nil, true, err
		}

		err = a.Realloc(int64(root), h2b(r, h)[:7])
		return
	}

	parentIndex := -1
	var parent int64
	ph := iroot

	for {
		var p btreePage
		if p, err = a.Get(p, ph); err != nil {
			return
		}

		var index int
		var ok bool

		if index, ok, err = p.find(a, c, key); err != nil {
			return
		}

		switch {
		case ok: // Key found
			if p.isIndex() {
				ph = btreeIndexPage(p).dataPage(index)
				if p, err = a.Get(nil, ph); err != nil {
					return
				}

				if old, err = btreeDataPage(p).valueCopy(a, 0); err != nil {
					return
				}

				if value, written, err = upd(key, old); err != nil || !written {
					return
				}

				if _, err = btreeDataPage(p).swap(a, 0, value, true); err != nil {
					return
				}

				err = a.Realloc(ph, p)
				return
			}

			if old, err = btreeDataPage(p).valueCopy(a, index); err != nil {
				return
			}

			if value, written, err = upd(key, old); err != nil || !written {
				return
			}

			if _, err = btreeDataPage(p).swap(a, index, value, true); err != nil {
				return
			}

			err = a.Realloc(ph, p)
			return
		case p.isIndex():
			if p.len() > 2*kIndex {
				if err = (*btreeIndexPage)(&p).split(a, root, &ph, parent, parentIndex, &index); err != nil {
					return
				}
			}
			parentIndex = index
			parent = ph
			ph = btreeIndexPage(p).child(index)
		default:
			if value, written, err = upd(key, nil); err != nil || !written {
				return
			}

			if p.len() < 2*kData { // page is not full
				if err = (*btreeDataPage)(&p).insertItem(a, index, key, value); err != nil {
					return
				}

				err = a.Realloc(ph, p)
				return
			}

			// page is full
			err = (*btreeDataPage)(&p).overflow(a, int64(root), ph, parent, parentIndex, index, key, value)
			return
		}
	}
}

func (root btree) get(a btreeStore, dst []byte, c func(a, b []byte) int, key []byte) (b []byte, err error) {
	var r []byte
	if r, err = a.Get(dst, int64(root)); err != nil {
		return
	}

	iroot := b2h(r)
	if iroot == 0 {
		return
	}

	ph := iroot

	for {
		var p btreePage
		if p, err = a.Get(p, ph); err != nil {
			return
		}

		var index int
		var ok bool
		if index, ok, err = p.find(a, c, key); err != nil {
			return
		}

		switch {
		case ok:
			if p.isIndex() {
				dh := btreeIndexPage(p).dataPage(index)
				dp, err := a.Get(dst, dh)
				if err != nil {
					return nil, err
				}

				return btreeDataPage(dp).value(a, 0)
			}

			return btreeDataPage(p).value(a, index)
		case p.isIndex():
			ph = btreeIndexPage(p).child(index)
		default:
			return
		}
	}
}

func (root btree) extract(a btreeStore, dst []byte, c func(a, b []byte) int, key []byte) (value []byte, err error) {
	var r []byte
	if r, err = a.Get(dst, int64(root)); err != nil {
		return
	}

	iroot := b2h(r)
	if iroot == 0 {
		return
	}

	ph := iroot
	parentIndex := -1
	var parent int64
	for {
		var p btreePage
		if p, err = a.Get(p, ph); err != nil {
			return
		}

		var index int
		var ok bool
		if index, ok, err = p.find(a, c, key); err != nil {
			return
		}

		if ok {
			if p.isIndex() {
				dph := btreeIndexPage(p).dataPage(index)
				dp, err := a.Get(dst, dph)
				if err != nil {
					return nil, err
				}

				if btreeDataPage(dp).len() > kData {
					if value, err = (*btreeDataPage)(&dp).extract(a, 0); err != nil {
						return nil, err
					}

					return value, a.Realloc(dph, dp)
				}

				if btreeIndexPage(p).len() < kIndex && ph != iroot {
					if err = (*btreeIndexPage)(&p).underflow(a, int64(root), iroot, parent, &ph, parentIndex, &index); err != nil {
						return nil, err
					}
				}
				parentIndex = index + 1
				parent = ph
				ph = btreeIndexPage(p).child(parentIndex)
				continue
			}

			value, err = (*btreeDataPage)(&p).extract(a, index)
			if p.len() >= kData {
				err = a.Realloc(ph, p)
				return
			}

			if ph != iroot {
				err = btreeDataPage(p).underflow(a, int64(root), iroot, parent, ph, parentIndex)
				return
			}

			if p.len() == 0 {
				if err = a.Free(ph); err != nil {
					return
				}

				err = a.Realloc(int64(root), zeros[:7])
				return
			}
			err = a.Realloc(ph, p)
			return
		}

		if !p.isIndex() {
			return
		}

		if p.len() < kIndex && ph != iroot {
			if err = (*btreeIndexPage)(&p).underflow(a, int64(root), iroot, parent, &ph, parentIndex, &index); err != nil {
				return nil, err
			}
		}
		parentIndex = index
		parent = ph
		ph = btreeIndexPage(p).child(index)
	}
}

func (root btree) deleteAny(a btreeStore) (bool, error) {
	var r []byte
	var err error
	if r, err = a.Get(nil, int64(root)); err != nil {
		return false, err
	}

	iroot := b2h(r)
	if iroot == 0 {
		return true, nil
	}

	ph := iroot
	parentIndex := -1
	var parent int64
	for {
		var p btreePage
		if p, err = a.Get(p, ph); err != nil {
			return false, err
		}

		index := p.len() / 2
		if p.isIndex() {
			dph := btreeIndexPage(p).dataPage(index)
			dp, err := a.Get(nil, dph)
			if err != nil {
				return false, err
			}

			if btreeDataPage(dp).len() > kData {
				if _, err = (*btreeDataPage)(&dp).extract(a, 0); err != nil {
					return false, err
				}

				return false, a.Realloc(dph, dp)
			}

			if btreeIndexPage(p).len() < kIndex && ph != iroot {
				if err = (*btreeIndexPage)(&p).underflow(a, int64(root), iroot, parent, &ph, parentIndex, &index); err != nil {
					return false, err
				}
			}
			parentIndex = index + 1
			parent = ph
			ph = btreeIndexPage(p).child(parentIndex)
			continue
		}

		_, err = (*btreeDataPage)(&p).extract(a, index)
		if p.len() >= kData {
			err = a.Realloc(ph, p)
			return false, err
		}

		if ph != iroot {
			err = btreeDataPage(p).underflow(a, int64(root), iroot, parent, ph, parentIndex)
			return false, err
		}

		if p.len() == 0 {
			if err = a.Free(ph); err != nil {
				return true, err
			}

			return true, a.Realloc(int64(root), zeros[:7])
		}

		return false, a.Realloc(ph, p)
	}
}

func (root btree) first(a btreeStore) (ph int64, p btreeDataPage, err error) {
	var r []byte
	if r, err = a.Get(nil, int64(root)); err != nil {
		return
	}

	for ph = b2h(r); ph != 0; ph = btreeIndexPage(p).child(0) {
		if p, err = a.Get(p, ph); err != nil {
			return
		}

		if !btreePage(p).isIndex() {
			break
		}
	}

	return
}

func (root btree) last(a btreeStore) (ph int64, p btreeDataPage, err error) {
	var r []byte
	if r, err = a.Get(nil, int64(root)); err != nil {
		return
	}

	for ph = b2h(r); ph != 0; ph = btreeIndexPage(p).child(btreeIndexPage(p).len()) {
		if p, err = a.Get(p, ph); err != nil {
			return
		}

		if !btreePage(p).isIndex() {
			break
		}
	}

	return
}

// key >= p[index].key
func (root btree) seek(a btreeStore, c func(a, b []byte) int, key []byte) (p btreeDataPage, index int, equal bool, err error) {
	var r []byte
	if r, err = a.Get(nil, int64(root)); err != nil {
		return
	}

	for ph := b2h(r); ph != 0; ph = btreeIndexPage(p).child(index) {
		if p, err = a.Get(p, ph); err != nil {
			break
		}

		if index, equal, err = btreePage(p).find(a, c, key); err != nil {
			break
		}

		if equal {
			if !btreePage(p).isIndex() {
				break
			}

			p, err = a.Get(p, btreeIndexPage(p).dataPage(index))
			index = 0
			break
		}

		if !btreePage(p).isIndex() {
			break
		}
	}
	return
}

func (root btree) clear(a btreeStore) (err error) {
	var r []byte
	if r, err = a.Get(nil, int64(root)); err != nil {
		return
	}

	iroot := b2h(r)
	if iroot == 0 {
		return
	}

	if err = root.clear2(a, iroot); err != nil {
		return
	}

	var b [7]byte
	return a.Realloc(int64(root), b[:])
}

func (root btree) clear2(a btreeStore, ph int64) (err error) {
	var p []byte
	if p, err = a.Get(nil, ph); err != nil {
		return
	}

	switch btreePage(p).isIndex() {
	case true:
		ip := btreeIndexPage(p)
		for i := 0; i <= ip.len(); i++ {
			root.clear2(a, ip.child(i))

		}
	case false:
		dp := btreeDataPage(p)
		for i := 0; i < dp.len(); i++ {
			if err = dp.setKey(a, i, nil); err != nil {
				return
			}

			if err = dp.setValue(a, i, nil); err != nil {
				return
			}
		}
	}
	return a.Free(ph)
}
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lldb

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"math"
	"math/rand"
	"os"
	"runtime"
	"testing"

	"github.com/cznic/mathutil"
)

var (
	testFrom = flag.Uint("from", 0, "test I [-from, -N)")
	noGrow   = flag.Bool("noGrow", false, "check only embeded keys/values")
)

func verifyPageLinks(a btreeStore, tree btree, n int) (err error) {
	var p btreeDataPage
	var ph int64
	if ph, p, err = tree.first(a); err != nil {
		return
	}

	if n == 0 {
		if ph != 0 || p != nil {
			return fmt.Errorf("first() should returned nil page")
		}

		ph2, p2, err := tree.last(a)
		if err != nil {
			return err
		}

		if ph2 != 0 || p2 != nil {
			return fmt.Errorf("last() should returned nil page")
		}

	}

	n0 := n
	var prev int64
	var lastKey []byte
	for ph != 0 {
		if p, err = a.Get(nil, ph); err != nil {
			return
		}

		if g, e := p.prev(), prev; g != e {
			return fmt.Errorf("broken L-R DLL chain: p %d p.prev %d, exp %d", ph, g, e)
		}

		for i := 0; i < p.len(); i++ {
			key, err := p.key(a, i)
			if err != nil {
				return err
			}

			if key == nil {
				return fmt.Errorf("nil key")
			}

			if lastKey != nil && !(bytes.Compare(lastKey, key) < 0) {
				return fmt.Errorf("L-R key ordering broken")
			}

			lastKey = key
			n--
		}

		prev, ph = ph, p.next()
	}

	if n != 0 {
		return fmt.Errorf("# of keys off by %d (L-R)", n)
	}

	n = n0
	if ph, p, err = tree.last(a); err != nil {
		return
	}

	lastKey = nil
	var next int64

	for ph != 0 {
		if p, err = a.Get(nil, ph); err != nil {
			return
		}

		if g, e := p.next(), next; g != e {
			return fmt.Errorf("broken R-L DLL chain")
		}

		for i := p.len() - 1; i >= 0; i-- {
			key, err := p.key(a, i)
			if err != nil {
				return err
			}

			if key == nil {
				return fmt.Errorf("nil key")
			}

			if lastKey != nil && !(bytes.Compare(key, lastKey) < 0) {
				return fmt.Errorf("R-L key ordering broken")
			}

			lastKey = key
			n--
		}

		next, ph = ph, p.prev()
	}

	if n != 0 {
		return fmt.Errorf("# of keys off by %d (R-L)", n)
	}

	return
}

func testBTreePut1(t *testing.T, nf func() btreeStore, grow, from, to, xor int64) (tree btree) {
	if *noGrow {
		grow = 0
	}

	a := nf()
	if a == nil {
		t.Fatal(a)
	}

	var err error
	tree, err = newBTree(a)
	if err != nil {
		t.Fatal(err)
	}

	if err := verifyPageLinks(a, tree, 0); err != nil {
		t.Fatal(err)
	}

	// Write and read back
	var k, v, prevValue [7]byte

	n := 0
	for i := from; i < to; i++ {
		h2b(k[:], 0x0100000000+i^xor)
		h2b(v[:], 0x0200000000+i^xor)
		kk := append(make([]byte, grow*i), k[:]...)
		vv := append(make([]byte, grow*i), v[:]...)
		prev, err := tree.put(a, nil, kk, vv, true)
		if err != nil || len(prev) != 0 {
			t.Fatal(i, prev, err)
		}

		var buf []byte
		if buf, err = tree.get(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(buf, vv) {
			t.Fatalf("\nK %sG %sE %s%s", hex.Dump(kk), hex.Dump(buf), hex.Dump(vv), tree.String(a))
		}

		n++
	}

	if err := verifyPageLinks(a, tree, n); err != nil {
		t.Fatalf("%s\n%s", err, tree.String(a))
	}

	// Overwrite, read and extract
	for i := from; i < to; i++ {
		h2b(k[:], 0x0100000000+i^xor)
		h2b(prevValue[:], 0x0200000000+i^xor)
		h2b(v[:], 0x0300000000+i^xor)
		kk := append(make([]byte, grow*i), k[:]...)
		vv := append(make([]byte, grow*i), v[:]...)
		expPrev := append(make([]byte, grow*i), prevValue[:]...)
		gotPrev, err := tree.put(a, nil, kk, vv, true)
		if err != nil {
			t.Fatal(i, err)
		}

		if !bytes.Equal(gotPrev, expPrev) {
			t.Fatalf("\nK %sG %sE %s%s", hex.Dump(kk), hex.Dump(gotPrev), hex.Dump(expPrev), tree.String(a))
		}

		var buf []byte
		if buf, err = tree.get(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(buf, vv) {
			t.Fatalf("\n%s%s%s%s", hex.Dump(kk), hex.Dump(buf), hex.Dump(vv), tree.String(a))
		}

		buf = nil
		if buf, err = tree.extract(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(buf, vv) {
			t.Fatalf("i %d, from [%d, %d)\nK %sG %sE %s%s", i, from, to, hex.Dump(kk), hex.Dump(buf), hex.Dump(vv), tree.String(a))
		}

		buf = nil
		if buf, err = tree.get(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if buf != nil {
			t.Fatalf("\nK %sB %s%s", hex.Dump(kk), hex.Dump(buf), tree.String(a))
		}

		buf = nil
		if buf, err = tree.extract(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if buf != nil {
			t.Fatalf("\n%s\n%s%s", hex.Dump(kk), hex.Dump(buf), tree.String(a))
		}

		n--
		if err := verifyPageLinks(a, tree, n); err != nil {
			t.Fatalf("%s\n%s", err, tree.String(a))
		}
	}

	return
}

var xors = [...]int64{0, 0xffffffff, 0x55555555, 0xaaaaaaaa}

func TestBTreePutGetExtract(t *testing.T) {
	N := int64(3 * kData)
	from := int64(*testFrom)

	for grow := 0; grow < 2; grow++ {
		for _, x := range xors {
			var s *memBTreeStore
			tree := testBTreePut1(t, func() btreeStore { s = newMemBTreeStore(); return s }, int64(grow), from, N, x)
			if err := verifyPageLinks(s, tree, 0); err != nil {
				t.Fatal(err)
			}

			if g, e := len(s.m), 1; g != e {
				t.Fatalf("leak(s) %d %d\n%s", g, e, s)
			}
		}
	}
}

func testBTreePut2(t *testing.T, nf func() btreeStore, grow, n int) (tree btree) {
	if *noGrow {
		grow = 0
	}
	rng, err := mathutil.NewFC32(math.MinInt32, math.MaxInt32, true)
	if err != nil {
		t.Fatal(err)
	}

	a := nf()
	if a == nil {
		t.Fatal(a)
	}

	tree, err = newBTree(a)
	if err != nil {
		t.Fatal(err)
	}

	var k, v [7]byte
	for i := 0; i < n; i++ {
		ik, iv := int64(rng.Next()), int64(rng.Next())
		h2b(k[:], ik)
		h2b(v[:], iv)
		kk := append(make([]byte, grow*i), k[:]...)
		vv := append(make([]byte, grow*i), v[:]...)
		prev, err := tree.put(a, nil, kk, vv, true)
		if err != nil || len(prev) != 0 {
			t.Fatal(i, prev, err)
		}

		var buf []byte
		if buf, err = tree.get(a, nil, nil, kk); err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(buf, vv) {
			t.Fatalf("\n%s%s%s%s", hex.Dump(kk), hex.Dump(buf), hex.Dump(vv), tree.String(a))
		}
	}

	if err := verifyPageLinks(a, tree, n); err != nil {
		t.Fatalf("%s\n%s\n", err, tree.String(a))
	}

	rng.Seek(0)
	for i := 0; i < n; i++ {
		ik, iv := int64(rng.Next()), int64(rng.Next())
		h2b(k[:], ik)
		h2b(v[:], iv)
		kk := append(make([]byte, grow*i), k[:]...)
		vv := append(make([]byte, grow*i), v[:]...)
		var buf []byte
		buf, err := tree.extract(a, nil, nil, kk)
		if err != nil {
			t.Fatal(i, err)
		}

		if !bytes.Equal(buf, vv) {
			t.Fatalf("\n%s\n%s\n%s\n%s", hex.Dump(kk), hex.Dump(buf), hex.Dump(vv), tree.String(a))
		}

		if err := verifyPageLinks(a, tree, n-i-1); err != nil {
			t.Fatalf("%s\n%s", err, tree.String(a))
		}
	}

	return
}

func TestBTreePutGetExtractRnd(t *testing.T) {
	N := *testN

	for grow := 0; grow < 2; grow++ {
		var s *memBTreeStore
		tree := testBTreePut2(t, func() btreeStore { s = newMemBTreeStore(); return s }, grow, N)
		if err := verifyPageLinks(s, tree, 0); err != nil {
			t.Fatal(err)
		}

		if g, e := len(s.m), 1; g != e {
			t.Fatalf("leak(s) %d %d\n%s", g, e, s)
		}
	}
}

func benchmarkBTreePut(b *testing.B, v []byte) {
	b.StopTimer()
	rng := rand.New(rand.NewSource(42))
	ka := make([][7]byte, b.N)
	for _, v := range ka {
		h2b(v[:], int64(rng.Int63()))
	}
	a := newMemBTreeStore()
	tree, err := newBTree(a)
	if err != nil {
		b.Fatal(err)
	}

	runtime.GC()
	b.StartTimer()
	for _, k := range ka {
		tree.put(a, bytes.Compare, k[:], v, true)
	}
}

func BenchmarkBTreePut0(b *testing.B) {
	benchmarkBTreePut(b, nil)
}

func BenchmarkBTreePut8(b *testing.B) {
	v := make([]byte, 8)
	benchmarkBTreePut(b, v)
}

func BenchmarkBTreePut16(b *testing.B) {
	v := make([]byte, 16)
	benchmarkBTreePut(b, v)
}

func BenchmarkBTreePut32(b *testing.B) {
	v := make([]byte, 32)
	benchmarkBTreePut(b, v)
}

func benchmarkBTreeGet(b *testing.B, v []byte) {
	b.StopTimer()
	rng := rand.New(rand.NewSource(42))
	ka := make([][7]byte, b.N)
	for _, v := range ka {
		h2b(v[:], int64(rng.Int63()))
	}
	a := newMemBTreeStore()
	tree, err := newBTree(a)
	if err != nil {
		b.Fatal(err)
	}

	for _, k := range ka {
		tree.put(a, bytes.Compare, k[:], v, true)
	}
	runtime.GC()
	b.StartTimer()
	for _, k := range ka {
		tree.get(a, nil, bytes.Compare, k[:])
	}
}

func BenchmarkBTreeGet0(b *testing.B) {
	benchmarkBTreeGet(b, nil)
}

func BenchmarkBTreeGet8(b *testing.B) {
	v := make([]byte, 8)
	benchmarkBTreeGet(b, v)
}

func BenchmarkBTreeGet16(b *testing.B) {
	v := make([]byte, 16)
	benchmarkBTreeGet(b, v)
}

func BenchmarkBTreeGet32(b *testing.B) {
	v := make([]byte, 32)
	benchmarkBTreeGet(b, v)
}

func TestBTreeSeek(t *testing.T) {
	N := int64(*testN)

	tree := NewBTree(nil)

	// Fill
	for i := int64(1); i <= N; i++ {
		tree.Set(enc8(10*i), enc8(10*i+1))
	}

	// Check
	a, root := tree.store, tree.root
	for i := int64(1); i <= N; i++ {
		// Exact match
		lowKey := enc8(10*i - 1)
		key := enc8(10 * i)
		highKey := enc8(10*i + 1)
		p, index, eq, err := root.seek(a, nil, key)
		if err != nil {
			t.Fatal(err)
		}

		if !eq {
			t.Fatal(i)
		}

		if btreePage(p).isIndex() {
			t.Fatal(i, "need btreeDataPage")
		}

		dp := btreeDataPage(p)
		n := dp.len()
		if n < 0 || n > 2*kData {
			t.Fatal(i, n)
		}

		if index < 0 || index >= n {
			t.Fatal(index)
		}

		g, err := dp.key(a, index)
		if err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(g, key) {
			t.Fatal(i)
		}

		g, err = dp.value(a, index)
		if err != nil {
			t.Fatal(err)
		}

		value := enc8(10*i + 1)
		if !bytes.Equal(g, value) {
			t.Fatal(i)
		}

		// Nonexistent "low" key. Search for 9 should return the key 10.
		p, index, eq, err = root.seek(a, nil, lowKey)
		if err != nil {
			t.Fatal(err)
		}

		if eq {
			t.Fatal(i)
		}

		if btreePage(p).isIndex() {
			t.Fatal(i, "need btreeDataPage")
		}

		dp = btreeDataPage(p)
		n = dp.len()
		if n < 0 || n > 2*kData {
			t.Fatal(i, n)
		}

		if index < 0 || index > n {
			t.Fatal(index, n)
		}

		if index == n {
			ph := dp.next()
			index = 0
			if dp, err = a.Get(p, ph); err != nil {
				t.Fatal(err)
			}
		}

		g, err = dp.key(a, index)
		if err != nil {
			t.Fatal(err)
		}

		expKey := key
		if !bytes.Equal(g, expKey) {
			fmt.Println(root.String(a))
			//t.Fatalf("%d low|% x| g|% x| e|% x|", i, lowKey, g, expKey)
		}

		g, err = dp.value(a, index)
		if err != nil {
			t.Fatal(err)
		}

		value = enc8(10*i + 1)
		if !bytes.Equal(g, value) {
			t.Fatal(i)
		}

		// Nonexistent "high" key. Search for 11 should return the key 20.
		p, index, eq, err = root.seek(a, nil, highKey)
		if err != nil {
			t.Fatal(err)
		}

		if eq {
			t.Fatal(i)
		}

		if btreePage(p).isIndex() {
			t.Fatal(i, "need btreeDataPage")
		}

		dp = btreeDataPage(p)
		n = dp.len()
		if n < 0 || n > 2*kData {
			t.Fatal(i, n)
		}

		if index < 0 || index > n {
			t.Fatal(index, n)
		}

		if index == n {
			ph := dp.next()
			if i == N {
				if ph != 0 {
					t.Fatal(ph)
				}

				continue
			}

			index = 0
			if dp, err = a.Get(p, ph); err != nil {
				t.Fatal(err)
			}
		}

		g, err = dp.key(a, index)
		if err != nil {
			t.Fatal(err)
		}

		expKey = enc8(10 * (i + 1))
		if !bytes.Equal(g, expKey) {
			//fmt.Println(root.String(a))
			t.Fatalf("%d low|% x| g|% x| e|% x|", i, lowKey, g, expKey)
		}

		g, err = dp.value(a, index)
		if err != nil {
			t.Fatal(err)
		}

		value = enc8(10*(i+1) + 1)
		if !bytes.Equal(g, value) {
			t.Fatal(i)
		}

	}
}

func enc8(n int64) []byte {
	var b [8]byte
	h2b(b[:], n)
	return b[:]
}

func dec8(b []byte) (int64, error) {
	if len(b) != 0 {
		return 0, fmt.Errorf("dec8: len != 8 but %d", len(b))
	}

	return b2h(b), nil
}

func TestBTreeNext(t *testing.T) {
	N := int64(*testN)

	tree := NewBTree(nil)
	enum, _, err := tree.Seek(enc8(0))
	if err != nil {
		t.Fatal(err)
	}

	if _, _, err = enum.Current(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Next(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Prev(); err != io.EOF {
		t.Fatal(err)
	}

	// Fill
	for i := int64(1); i <= N; i++ {
		tree.Set(enc8(10*i), enc8(10*i+1))
	}

	var eq bool

	enum, eq, err = tree.Seek(enc8(0))
	if err != nil {
		t.Fatal(err)
	}

	if eq {
		t.Fatal(eq)
	}

	// index: 0
	if _, _, err = enum.Current(); err != nil {
		t.Fatal(err)
	}

	if err = enum.Next(); N > 1 && err != nil {
		t.Fatal(err)
	}

	enum, eq, err = tree.Seek(enc8(N * 10))
	if err != nil {
		t.Fatal(err)
	}

	if !eq {
		t.Fatal(eq)
	}

	// index: N-1
	if _, _, err = enum.Current(); err != nil {
		t.Fatal(err)
	}

	if err = enum.Next(); N > 1 && err != io.EOF {
		t.Fatal(err)
	}

	enum, eq, err = tree.Seek(enc8(N*10 + 1))
	if err != nil {
		t.Fatal(err)
	}

	if eq {
		t.Fatal(eq)
	}

	// index: N
	if _, _, err = enum.Current(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Next(); N > 1 && err != io.EOF {
		t.Fatal(err)
	}

	enum, _, err = tree.Seek(enc8(0))
	if err != nil {
		t.Fatal(err)
	}

	for i := int64(1); i <= N; i++ {
		expKey, expValue := enc8(10*i), enc8(10*i+1)
		k, v, err := enum.Current()
		if err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(k, expKey) {
			t.Fatal(i)
		}

		if !bytes.Equal(v, expValue) {
			t.Fatal(i)
		}

		switch {
		case i == N:
			if err := enum.Next(); err != io.EOF {
				t.Fatal(err)
			}
		default:
			if err := enum.Next(); err != nil {
				t.Fatal(err)
			}
		}
	}
}

func TestBTreePrev(t *testing.T) {
	N := int64(*testN)

	tree := NewBTree(nil)
	enum, _, err := tree.Seek(enc8(0))
	if err != nil {
		t.Fatal(err)
	}

	if _, _, err = enum.Current(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Next(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Prev(); err != io.EOF {
		t.Fatal(err)
	}

	// Fill
	for i := int64(1); i <= N; i++ {
		tree.Set(enc8(10*i), enc8(10*i+1))
	}

	var eq bool

	enum, eq, err = tree.Seek(enc8(0))
	if err != nil {
		t.Fatal(err)
	}

	if eq {
		t.Fatal(eq)
	}

	// index: 0
	if _, _, err = enum.Current(); err != nil {
		t.Fatal(err)
	}

	if err = enum.Prev(); err != io.EOF {
		t.Fatal(err)
	}

	enum, eq, err = tree.Seek(enc8(N * 10))
	if err != nil {
		t.Fatal(err)
	}

	if !eq {
		t.Fatal(eq)
	}

	// index: N-1
	if _, _, err = enum.Current(); err != nil {
		t.Fatal(err)
	}

	if err = enum.Prev(); N > 1 && err != nil {
		t.Fatal(err)
	}

	enum, eq, err = tree.Seek(enc8(N*10 + 1))
	if err != nil {
		t.Fatal(err)
	}

	if eq {
		t.Fatal(eq)
	}

	// index: N
	if _, _, err = enum.Current(); err != io.EOF {
		t.Fatal(err)
	}

	if err = enum.Prev(); err != nil {
		t.Fatal(err)
	}

	enum, _, err = tree.Seek(enc8(N * 10))
	if err != nil {
		t.Fatal(err)
	}

	for i := N; i >= 1; i-- {
		expKey, expValue := enc8(10*i), enc8(10*i+1)
		k, v, err := enum.Current()
		if err != nil {
			t.Fatal(err)
		}

		if !bytes.Equal(k, expKey) {
			t.Fatalf("%d k|% x| expK|% x| %s\n", i, k, expKey, tree.root.String(tree.store))
		}

		if !bytes.Equal(v, expValue) {
			t.Fatal(i)
		}

		switch {
		case i == 1:
			if err := enum.Prev(); err != io.EOF {
				t.Fatal(err)
			}
		default:
			if err := enum.Prev(); err != nil {
				t.Fatal(i, err)
			}
		}
	}
}

func TestBTreeClear(t *testing.T) {
	N := int64(*testN)

	var err error
	var p []byte
	for n := int64(0); n <= N; n = n*3/2 + 1 {
		tree := NewBTree(nil)
		for i := int64(0); i < n; i++ {
			k := append(make([]byte, kKV), enc8(10*i+1)...)
			v := append(make([]byte, kKV+1), enc8(10*i+2)...)
			if err = tree.Set(k, v); err != nil {
				t.Fatal(err)
			}
		}

		if err = tree.Clear(); err != nil {
			t.Fatal(err)
		}

		if g, e := len(tree.store.(*memBTreeStore).m), 1; g != e {
			t.Fatalf("%v %v %v\n%s", n, g, e, tree.store.(*memBTreeStore).String())
		}

		if p, err = tree.store.Get(p, 1); err != nil {
			t.Fatal(err)
		}

		if g, e := p, zeros[:7]; len(g) != 0 && !bytes.Equal(g, e) {
			t.Fatalf("|% x| |% x|", g, e)
		}
	}
}

func TestBTreeRemove(t *testing.T) {
	N := int64(*testN)

	for kind := 0; kind < fltInvalidKind; kind++ {
		for n := int64(0); n <= N; n = n*3/2 + 1 {
			f := NewMemFiler()
			flt, err := newCannedFLT(f, kind)
			if err != nil {
				t.Fatal(err)
			}

			sz0, err := f.Size()
			if err != nil {
				t.Fatal(err)
			}

			store, err := NewAllocator(f, flt)
			if err != nil {
				t.Fatal(err)
			}

			tree, handle, err := CreateBTree(store, nil)
			if err != nil {
				t.Fatal(err)
			}

			for i := int64(0); i < n; i++ {
				k := append(make([]byte, kKV), enc8(10*i+1)...)
				v := append(make([]byte, kKV+1), enc8(10*i+2)...)
				if err = tree.Set(k, v); err != nil {
					t.Fatal(err)
				}
			}

			if err = RemoveBTree(store, handle); err != nil {
				t.Fatal(err)
			}

			sz, err := f.Size()
			if err != nil {
				t.Fatal(err)
			}

			if g, e := sz-sz0, int64(0); g != e {
				t.Fatal(g, e)
			}
		}
	}
}

func collate(a, b []byte) (r int) {
	da, err := DecodeScalars(a)
	if err != nil {
		panic(err)
	}

	db, err := DecodeScalars(b)
	if err != nil {
		panic(err)
	}

	r, err = Collate(da, db, nil)
	if err != nil {
		panic(err)
	}

	return
}

func TestBTreeCollatingBug(t *testing.T) {
	tree := NewBTree(collate)

	date, err := EncodeScalars("Date")
	if err != nil {
		t.Fatal(err)
	}

	customer, err := EncodeScalars("Customer")
	if err != nil {
		t.Fatal(err)
	}

	if g, e := collate(customer, date), -1; g != e {
		t.Fatal(g, e)
	}

	if g, e := collate(date, customer), 1; g != e {
		t.Fatal(g, e)
	}

	err = tree.Set(date, nil)
	if err != nil {
		t.Fatal(err)
	}

	err = tree.Set(customer, nil)
	if err != nil {
		t.Fatal(err)
	}

	var b bytes.Buffer
	tree.Dump(&b)
	t.Logf("\n%s", b.String())

	key, _, err := tree.First()
	if err != nil {
		t.Fatal(err)
	}

	if g, e := key, customer; !bytes.Equal(g, e) {
		t.Fatal(g, e)
	}

}

func TestExtract(t *testing.T) { // Test of the exported wrapper only, .extract tested elsewhere
	bt := NewBTree(nil)
	bt.Set([]byte("a"), []byte("b"))
	bt.Set([]byte("c"), []byte("d"))
	bt.Set([]byte("e"), []byte("f"))

	if v, err := bt.Get([]byte("a")); string(v) != "b" || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Get([]byte("c")); string(v) != "d" || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Get([]byte("e")); string(v) != "f" || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Extract([]byte("c")); string(v) != "d" || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Get([]byte("a")); string(v) != "b" || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Get([]byte("c")); v != nil || err != nil {
		t.Fatal(v, err)
	}

	if v, err := bt.Get([]byte("e")); string(v) != "f" || err != nil {
		t.Fatal(v, err)
	}
}

func TestFirst(t *testing.T) {
	bt := NewBTree(nil)

	if k, v, err := bt.First(); k != nil || v != nil || err != nil {
		t.Fatal(k, v, err)
	}

	bt.Set([]byte("a"), []byte("b"))
	bt.Set([]byte("c"), []byte("d"))

	if k, v, err := bt.First(); string(k) != "a" || string(v) != "b" || err != nil {
		t.Fatal(k, v, err)
	}

	if err := bt.Delete([]byte("a")); err != nil {
		t.Fatal(err)
	}

	if k, v, err := bt.First(); string(k) != "c" || string(v) != "d" || err != nil {
		t.Fatal(k, v, err)
	}

	if err := bt.Delete([]byte("c")); err != nil {
		t.Fatal(err)
	}

	if k, v, err := bt.First(); k != nil || v != nil || err != nil {
		t.Fatal(k, v, err)
	}
}

func TestLast(t *testing.T) {
	bt := NewBTree(nil)

	if k, v, err := bt.First(); k != nil || v != nil || err != nil {
		t.Fatal(k, v, err)
	}

	bt.Set([]byte("a"), []byte("b"))
	bt.Set([]byte("c"), []byte("d"))

	if k, v, err := bt.Last(); string(k) != "c" || string(v) != "d" || err != nil {
		t.Fatal(k, v, err)
	}

	if err := bt.Delete([]byte("c")); err != nil {
		t.Fatal(err)
	}

	if k, v, err := bt.First(); string(k) != "a" || string(v) != "b" || err != nil {
		t.Fatal(k, v, err)
	}

	if err := bt.Delete([]byte("a")); err != nil {
		t.Fatal(err)
	}

	if k, v, err := bt.First(); k != nil || v != nil || err != nil {
		t.Fatal(k, v, err)
	}
}

func TestSeekFirst(t *testing.T) {
	bt := NewBTree(nil)

	enum, err := bt.SeekFirst()
	if err != io.EOF {
		t.Fatal(err)
	}

	bt.Set([]byte("c"), []byte("d"))
	enum, err = bt.SeekFirst()
	if err != nil {
		t.Fatal(err)
	}

	err = enum.Prev()
	if err != io.EOF {
		t.Fatal(err)
	}

	err = enum.Next()
	if err != io.EOF {
		t.Fatal(err)
	}

	k, v, err := enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "c" || string(v) != "d" {
		t.Fatal(k, v)
	}

	bt.Set([]byte("a"), []byte("b"))
	enum, err = bt.SeekFirst()
	if err != nil {
		t.Fatal(err)
	}

	err = enum.Prev()
	if err != io.EOF {
		t.Fatal(err)
	}

	k, v, err = enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "a" || string(v) != "b" {
		t.Fatal(k, v)
	}

	err = enum.Next()
	if err != nil {
		t.Fatal(err)
	}

	k, v, err = enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "c" || string(v) != "d" {
		t.Fatal(k, v)
	}
}

func TestSeekLast(t *testing.T) {
	bt := NewBTree(nil)

	enum, err := bt.SeekFirst()
	if err != io.EOF {
		t.Fatal(err)
	}

	bt.Set([]byte("a"), []byte("b"))
	enum, err = bt.SeekFirst()
	if err != nil {
		t.Fatal(err)
	}

	err = enum.Prev()
	if err != io.EOF {
		t.Fatal(err)
	}

	err = enum.Next()
	if err != io.EOF {
		t.Fatal(err)
	}

	k, v, err := enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "a" || string(v) != "b" {
		t.Fatal(k, v)
	}

	bt.Set([]byte("c"), []byte("d"))
	enum, err = bt.SeekLast()
	if err != nil {
		t.Fatal(err)
	}

	err = enum.Next()
	if err != io.EOF {
		t.Fatal(err)
	}

	k, v, err = enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "c" || string(v) != "d" {
		t.Fatal(k, v)
	}

	err = enum.Prev()
	if err != nil {
		t.Fatal(err)
	}

	k, v, err = enum.Current()
	if err != nil {
		t.Fatal(err)
	}

	if string(k) != "a" || string(v) != "b" {
		t.Fatal(k, v)
	}
}

func TestDeleteAny(t *testing.T) {
	const N = 1e4
	rng := rand.New(rand.NewSource(42))
	ref := map[uint32]bool{}
	tr := NewBTree(nil)
	data := []byte{42}
	var key [4]byte
	for i := 0; i < N; i++ {
		k := uint32(rng.Int())
		binary.LittleEndian.PutUint32(key[:], k)
		if err := tr.Set(key[:], data); err != nil {
			t.Fatal(err)
		}

		ref[k] = true
	}

	for i := len(ref); i != 0; i-- {
		empty, err := tr.DeleteAny()
		if err != nil {
			t.Fatal(err)
		}

		if empty && i != 1 {
			t.Fatal(i)
		}
	}
}

func benchmarkBTreeSetFiler(b *testing.B, f Filer, sz int) {
	b.SetBytes(int64(sz))

	if err := f.BeginUpdate(); err != nil {
		b.Error(err)
		return
	}

	a, err := NewFLTAllocator(f, FLTPowersOf2)
	if err != nil {
		b.Error(err)
		return
	}

	tr, _, err := CreateBTree(a, nil)
	if err != nil {
		f.EndUpdate()
		b.Error(err)
		return
	}

	if err = f.EndUpdate(); err != nil {
		b.Error(err)
		return
	}

	keys := make([][8]byte, b.N)
	for i := range keys {
		binary.BigEndian.PutUint64(keys[i][:], uint64(i))
	}
	v := make([]byte, sz)
	runtime.GC()
	b.ResetTimer()
	for _, k := range keys {
		if err = f.BeginUpdate(); err != nil {
			b.Error(err)
			return
		}

		if err := tr.Set(k[:], v); err != nil {
			f.EndUpdate()
			b.Error(err)
			return
		}

		if err = f.EndUpdate(); err != nil {
			b.Error(err)
			return
		}
	}
}

func benchmarkBTreeSetMemFiler(b *testing.B, sz int) {
	f := NewMemFiler()
	benchmarkBTreeSetFiler(b, f, sz)
}

func BenchmarkBTreeSetMemFiler0(b *testing.B) {
	benchmarkBTreeSetMemFiler(b, 0)
}

func BenchmarkBTreeSetMemFiler1e1(b *testing.B) {
	benchmarkBTreeSetMemFiler(b, 1e1)
}

func BenchmarkBTreeSetMemFiler1e2(b *testing.B) {
	benchmarkBTreeSetMemFiler(b, 1e2)
}

func BenchmarkBTreeSetMemFiler1e3(b *testing.B) {
	benchmarkBTreeSetMemFiler(b, 1e3)
}

func benchmarkBTreeSetSimpleFileFiler(b *testing.B, sz int) {
	os.Remove(testDbName)
	f, err := os.OpenFile(testDbName, os.O_CREATE|os.O_EXCL|os.O_RDWR, 0600)
	if err != nil {
		b.Fatal(err)
	}

	defer func() {
		f.Close()
		os.Remove(testDbName)
	}()

	benchmarkBTreeSetFiler(b, NewSimpleFileFiler(f), sz)
}

func BenchmarkBTreeSetSimpleFileFiler0(b *testing.B) {
	benchmarkBTreeSetSimpleFileFiler(b, 0)
}

func BenchmarkBTreeSetSimpleFileFiler1e1(b *testing.B) {
	benchmarkBTreeSetSimpleFileFiler(b, 1e1)
}

func BenchmarkBTreeSetSimpleFileFiler1e2(b *testing.B) {
	benchmarkBTreeSetSimpleFileFiler(b, 1e2)
}

func BenchmarkBTreeSetSimpleFileFiler1e3(b *testing.B) {
	benchmarkBTreeSetSimpleFileFiler(b, 1e3)
}

func benchmarkBTreeSetRollbackFiler(b *testing.B, sz int) {
	os.Remove(testDbName)
	f, err := os.OpenFile(testDbName, os.O_CREATE|os.O_EXCL|os.O_RDWR, 0600)
	if err != nil {
		b.Fatal(err)
	}

	defer func() {
		f.Close()
		os.Remove(testDbName)
	}()

	g := NewSimpleFileFiler(f)
	var filer *RollbackFiler
	if filer, err = NewRollbackFiler(
		g,
		func() error {
			sz, err := filer.Size()
			if err != nil {
				return err
			}

			if err = g.Truncate(sz); err != nil {
				return err
			}

			return g.Sync()
		},
		g,
	); err != nil {
		b.Error(err)
		return
	}

	benchmarkBTreeSetFiler(b, filer, sz)
}

func BenchmarkBTreeSetRollbackFiler0(b *testing.B) {
	benchmarkBTreeSetRollbackFiler(b, 0)
}

func BenchmarkBTreeSetRollbackFiler1e1(b *testing.B) {
	benchmarkBTreeSetRollbackFiler(b, 1e1)
}

func BenchmarkBTreeSetRollbackFiler1e2(b *testing.B) {
	benchmarkBTreeSetRollbackFiler(b, 1e2)
}

func BenchmarkBTreeSetRollbackFiler1e3(b *testing.B) {
	benchmarkBTreeSetRollbackFiler(b, 1e3)
}

func benchmarkBTreeSetACIDFiler(b *testing.B, sz int) {
	os.Remove(testDbName)
	os.Remove(walName)
	f, err := os.OpenFile(testDbName, os.O_CREATE|os.O_EXCL|os.O_RDWR, 0600)
	if err != nil {
		b.Fatal(err)
	}

	defer func() {
		f.Close()
		os.Remove(testDbName)
	}()

	wal, err := os.OpenFile(walName, os.O_CREATE|os.O_EXCL|os.O_RDWR, 0600)
	if err != nil {
		b.Fatal(err)
	}

	defer func() {
		wal.Close()
		os.Remove(walName)
	}()

	filer, err := NewACIDFiler(NewSimpleFileFiler(f), wal)
	if err != nil {
		b.Error(err)
		return
	}

	benchmarkBTreeSetFiler(b, filer, sz)
}

func BenchmarkBTreeSetACIDFiler0(b *testing.B) {
	benchmarkBTreeSetACIDFiler(b, 0)
}

func BenchmarkBTreeSetACIDFiler1e1(b *testing.B) {
	benchmarkBTreeSetACIDFiler(b, 1e1)
}

func BenchmarkBTreeSetACIDFiler1e2(b *testing.B) {
	benchmarkBTreeSetACIDFiler(b, 1e2)
}

func BenchmarkBTreeSetACIDFiler1e3(b *testing.B) {
	benchmarkBTreeSetACIDFiler(b, 1e3)
}
